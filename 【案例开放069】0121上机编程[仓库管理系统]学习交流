请设计一个仓库管理系统，实现如下功能：

·         StorageSystem(int coldStorageNum, int coldStoragePrice, int normalStorageNum, int normalStoragePrice, int delay) — 初始化仓库信息。
o    仓库有冷藏和常温两种类型的储藏室，初始化其对应的数量和每天租赁价格；
o    若客户租赁过期且超出 delay 天后，依旧未提取货物，该储物区将被清空；

·         store(int date, int storageId, int storageType, int storageDays) — 在日期 date 为存单 storageId 租赁 storageType 类型的一个储藏室，并存放物品 storageDays 天。

o    若有空间则存储成功，则需预付 storageDays 天的费用（按照实际使用储藏室类型进行计算：天数 * 每日租赁价格），返回该费用；
§  当常温储藏室空间不足时，可使用空闲的冷藏储藏室存储；反之不可以；
§  date 为「租赁起始日期」，日期超过 date + storageDays 时开始过期

o    若无空间则不做任何处理，并返回 -1。
系统保证 storageId 参数全局唯一。storageType 为 0 表示冷藏， 1 表示常温。

·         retrieve(int date, int storageId) — 在日期 date ，客户取出存单 storageId （存单一定存在且未被提取）对应的物品：
o    若存单未过期时，则取出物品，并返回 0；
o    若存单过期但未超出 delay 天，则取出物品，并返回需要补交的费用（实际延迟天数 * 每日价格），实际延迟天数 = date - (「租赁起始日期」+ storageDays)；
o    若存单过期且已超出 delay 天（日期超过 「租赁起始日期」+ storageDays + delay ）时，则物品已被清空、取出失败，并返回 -1。
·         query(int date) — 请返回截止日期 date 时 3 种状态的存单数量序列，依次为：物品已成功取出、物品未取仍在仓库中、物品被清空的存单数量。

注意：保证函数 store、retrieve、query 的日期 date 参数按输入顺序非严格递增；

示例 1：

输入：
["StorageSystem","store","retrieve","query"]
[[2,2,1,1,2],[0,1,0,2],[3,1],[3]]

输出：[null,4,2,[1,0,0]]

解释：
StorageSystem obj = StorageSystem(2,2,1,1,2); // 初始化仓库，2 个冷藏室（每天价格 2）和 1 个常温室（每天价格 1），货物最多可以延期 2 天；
obj.store(0,1,0,2); // 在日期 0，存单 1 预定冷藏室 2 天；由于存在空闲冷藏室，返回支付款项 2*2 = 4
obj.retrieve(3,1); // 在日期 3 提取存单 1 对应物品。实际延迟天数为 1 = 3 - (0 + 2)，返回补交费用 2*1 = 2 ；因过期但未超出 2 天，不会被清空，
obj.query(3); // 当前物品已成功取出、物品未取仍在仓库中、物品被清空的存单各有 1 份、0 份、0 份，返回 [1,0,0]
注：输出中的 null 表示此对应函数无输出（其中：C 的构造函数有返回值，但是也是无需输出）

示例 2：

输入：
["StorageSystem","query","store","store","store","query","store","retrieve","store","query","query","retrieve"]
[[2,2,1,3,2],[0],[0,21,1,3],[1,22,1,4],[1,23,0,2],[1],[4,26,1,2],[5,21],[6,24,0,7],[7],[8],[9,22]]

输出：[null,[0,0,0],9,8,4,[0,3,0],-1,6,14,[1,2,1],[1,1,2],-1]

解释：
StorageSystem obj = StorageSystem(2,2,1,3,2); // 初始化仓库，2 个冷藏室（每天价格 2）和 1 个常温室（每天价格 3），货物最多可以延期 2 天；
obj.query(0); // 返回 [0,0,0]
obj.store(0,21,1,3); // 返回支付款项 3*3=9
obj.store(1,22,1,4); // 日期 1，存单编号 22，预定常温室 4 天；由于无未租赁的常温室，租赁冷藏室，返回 4*2=8
obj.store(1,23,0,2); // 返回支付款项 2*2=4
obj.query(1); // 返回 [0,3,0]
obj.store(4,26,1,2); // 由于无未租赁的常温室和冷藏室，返回 -1
obj.retrieve(5,21); // 此时存单 21 延迟天数为 2 = 5 - (0 + 3)，需补交费用为 2*3=6
obj.store(6,24,0,7); // 由于存单 23 过期且超出 2 天未提取（6 > 1 + 2 + 2），物品被清空。因此存在未租赁的冷藏室，返回 7*2=14
obj.query(7); // 返回 [1,2,1]
obj.query(8); // 由于存单 22 过期且超出 2 天未提取使物品清空，返回 [1,1,2]
obj.retrieve(9,22); // 此时存单 22 已被清空，返回 -1;
注：输出中的 null 表示此对应函数无输出（其中：C 的构造函数有返回值，但是也是无需输出）

提示：

1 <= store, retrieve, query 累计操作数 <= 1000
1 <= coldStorageNum, normalStorageNum <= 100
1 <= coldStoragePrice, normalStoragePrice <= 100
0 <= storageId <= 1000
0 <= date <= 10^4
1 <= delay, storageDays <= 100
0 <= storageType <= 1
class StorageSystem:
    def __init__(self, coldStorageNum: int, coldStoragePrice: int, normalStorageNum: int, normalStoragePrice: int,
                 delay: int):
        """
        系统保证 storageId 参数全局唯一。
        storageType 为 0 表示冷藏， 1 表示常温。
        """
        self.coldStorageNum = coldStorageNum
        self.coldStoragePrice = coldStoragePrice
        self.normalStorageNum = normalStorageNum
        self.normalStoragePrice = normalStoragePrice
        self.delay = delay

        """
        定义要用到的数据:
        1. 冷库、冷库商品数量
        2. 常温库，常温库商品数量
        3. 记录每个商品在哪个库
        """
        self.coldStorage = {}
        self.normalStorage = {}
        self.coldStorageCount = 0
        self.normalStorageCount = 0

        self.storageId = {}

        self.good_status = {
            'type1': set(),  # 物品已成功取出
            'type2': set(),  # 物品未取仍在仓库中
            'type3': set(),  # 物品被清空
        }

    def check_self(self, Storage, date: int):
        temp = []
        for storageId in Storage.keys():
            store_date, storageDays = Storage[storageId]
            if store_date + storageDays + self.delay < date:
                temp.append(storageId)
        for storageId in temp:
            Storage.pop(storageId)
            if Storage == self.coldStorage:
                self.coldStorageCount -= 1
            else:
                self.normalStorage -= 1
            self.good_status['type2'].remove(storageId)
            self.good_status['type3'].add(storageId)

    def store(self, date: int, storageId: int, storageType: int, storageDays: int):
        """
        在日期 date 为存单 storageId 租赁 storageType 类型的一个储藏室，
        并存放物品 storageDays 天。
        """
        self.check_self(self.coldStorage, date)
        self.check_self(self.normalStorage, date)
        if storageType == 0:  # 冷藏
            if self.coldStorageCount < self.coldStorageNum:
                self.coldStorage[storageId] = [date, storageDays]
                self.coldStorageCount += 1
                self.storageId[storageId] = 0
                self.good_status['type2'].add(storageId)  # 物品入库
                return storageDays * self.coldStoragePrice
            else:
                return -1
        elif storageType == 1:  # 常温
            if self.normalStorageCount < self.normalStorageNum:
                self.normalStorage[storageId] = [date, storageDays]
                self.normalStorageCount += 1
                self.storageId[storageId] = 1
                self.good_status['type2'].add(storageId)  # 物品入库
                return storageDays * self.normalStoragePrice
            # 常温空间不够，看看冷藏是否有空间
            elif self.normalStorageCount + self.coldStorageCount < self.normalStorageNum + self.coldStorageNum:
                self.coldStorage[storageId] = [date, storageDays]
                self.coldStorageCount += 1
                self.storageId[storageId] = 1
                self.good_status['type2'].add(storageId)  # 物品入库
                return storageDays * self.coldStoragePrice
            else:
                return -1

    def retrieve(self, date: int, storageId: int):
        self.check_self(self.coldStorage, date)
        self.check_self(self.normalStorage, date)
        if storageId in self.good_status['type3']:
            return -1
        if self.storageId[storageId] == 0:
            storage = self.coldStorage
            price = self.coldStoragePrice
            self.coldStorageCount -= 1
        else:
            storage = self.normalStorage
            price = self.normalStoragePrice
            self.normalStorageCount -= 1

        store_date, storageDays = storage[storageId]
        storage.pop(storageId)

        # 若存单未过期时，则取出物品，并返回 0；
        if date <= store_date + storageDays:
            self.good_status['type1'].add(storageId)  # 物品取走
            self.good_status['type2'].remove(storageId)  # 物品出库
            return 0
        # 若存单过期但未超出 delay 天，则取出物品，并返回需要补交的费用
        elif date <= store_date + storageDays + self.delay:
            self.good_status['type1'].add(storageId)  # 物品取走
            self.good_status['type2'].remove(storageId)  # 物品出库
            return price * (date - store_date - storageDays)
        else:
            self.good_status['type3'].add(storageId)  # 物品取走
            self.good_status['type2'].remove(storageId)  # 物品出库
            return -1

    def query(self, date: int):
        self.check_self(self.coldStorage, date)
        self.check_self(self.normalStorage, date)
        return [len(x) for x in self.good_status.values()]


