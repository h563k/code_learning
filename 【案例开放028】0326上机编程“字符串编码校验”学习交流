有一种校验码机制，用于数据传输中的数据完整性检查，规则如下：
l  在字符串中插入一些数字作为校验码，每个数字之后跟随对应个数的字符；
l  要求有校验码（校验码大于零并且无前导零），并且正确匹配、无歧义：
如，"helloworld" 在插入校验码之后可以为 "5hello5world"，即 5 + "hello" + 5 + "world"；
但是，有些字符串在进行校验时会产生歧义，比如 "109something" 可以校验为 10 + "9something" 或者 1 + "0" + 9 + "something"，故这类编码方式是有歧义的。

现给出一个字符串 encodedString，请判断这个字符串是否符合上述规则：

l  如果是，则返回去掉校验码后的字符串长度；
l  如果不是，则返回 -1。

示例 1：
输入：encodedString = "9computer012"
输出：10
解释：只可以解析为 9 + "computer0" + 1 + "2"，可以正确匹配（校验码与随后字符个数相同）且无歧义。返回去掉校验码后的字符串 "computer02" 的长度 10。


示例 2：
输入：encodedString = "118computer1a"
输出：-1
解释：可以解析为 11 + "8computer1a" 或 1 + "1" + 8 + "computer" + 1 + "a"，有两种解析方式，所以有歧义。


示例 3：
输入：encodedString = "1a02hw"
输出：-1
解释：0 不能作为校验码，02 也不能作为校验码，因此返回 -1。

提示：
1 <= encodedString.length <= 10^3

encodedString 仅由小写字母[a~z]和数字[0~9]构成

from leetcode import *

class Solution:
    def __init__(self):
        self.temp = []
        self.result = []

    def is_right(self, encoded_string):
        res = ''
        for temp in self.temp:
            res += ''.join(temp)
        return res == encoded_string

    def dfs(self, start_ind, encoded_string: str):
        # 符合条件的前提，是内容能够完整拼接成原字符串
        if self.is_right(encoded_string):
            self.result.append(self.temp.copy())
        lens = len(encoded_string)
        for i in range(start_ind, lens):
            temp = encoded_string[start_ind:i]
            # 判断为不为0的验证码
            if not temp.isdigit() or temp.startswith('0'):
                continue
            next = encoded_string[i:i + int(temp)]
            # 如果能够正确的获取验证码长度的字符串
            if len(next) == int(temp):
                self.temp.append([temp, next])
                self.dfs(i + int(temp), encoded_string)
                self.temp.pop()

    def get_length(self, encoded_string: str) -> int:
        self.dfs(0, encoded_string)
        if len(self.result) == 1:
            lens = 0
            for result in self.result[0]:
                lens += int(result[0])
            return lens
        else:
            return -1
encoded_string = "9computer012"
sol = Solution()
sol.get_length(encoded_string)
